---
title: "Biostat 203B Homework 2"
subtitle: Due Feb 7, 2025 @ 11:59PM
author: Amaan Jogia-Sattar, 206324648
format:
  html:
    theme: cosmo
    embed-resources: true
    number-sections: false
    toc: true
    toc-depth: 4
    toc-location: left
    code-fold: false
    link-external-icon: true
    link-external-newwindow: true
---

Display machine information for reproducibility:
```{r}
sessionInfo()
```

Load necessary libraries (you can add more as needed).
```{r setup}
library(arrow)
library(data.table)
library(duckdb)
library(memuse)
library(pryr)
library(R.utils)
library(tidyverse)
```

Display memory information of your computer
```{r}
memuse::Sys.meminfo()
```

In this exercise, we explore various tools for ingesting the [MIMIC-IV](https://physionet.org/content/mimiciv/3.1/) data introduced in [homework 1](https://ucla-biostat-203b.github.io/2025winter/hw/hw1/hw1.html).

Display the contents of MIMIC `hosp` and `icu` data folders:

```{bash}
ls -l ~/mimic/hosp/
```

```{bash}
ls -l ~/mimic/icu/
```

## Q1. `read.csv` (base R) vs `read_csv` (tidyverse) vs `fread` (data.table)

### Q1.1 Speed, memory, and data types

There are quite a few utilities in R for reading plain text data files. Let us test the speed of reading a moderate sized compressed csv file, `admissions.csv.gz`, by three functions: `read.csv` in base R, `read_csv` in tidyverse, and `fread` in the data.table package.

Which function is fastest? Is there difference in the (default) parsed data types? How much memory does each resultant dataframe or tibble use? (Hint: `system.time` measures run times; `pryr::object_size` measures memory usage; all these readers can take gz file as input without explicit decompression.) 

**Solution** Comparing function speeds:

We will compute the runtimes and memory usage of each function. Note that the runtime utilized corresponds to the `elapsed` runtime as displayed by `system.time`. 
```{r}
# read.csv (base r) 
# speed
runtime_base <- system.time(
  {admissions_base <- read.csv('~/mimic/hosp/admissions.csv.gz')}
  )[['elapsed']]
# memory usage
memuse_base <- format(object_size(admissions_base), units = 'auto')
```

```{r}
# Measure runtime
runtime_tidy <- system.time(
  {admissions_tidy <- read.csv('~/mimic/hosp/admissions.csv.gz')}
)[['elapsed']]

# memory usage
memuse_tidy <- format(object_size(admissions_tidy), units = 'auto')
```

```{r}
# fread (data.table package) speed
runtime_dt <- system.time(
  {admissions_dt <- fread('~/mimic/hosp/admissions.csv.gz')}
)[['elapsed']]
# memory usage
memuse_dt <- format(object_size(admissions_dt), units = 'auto')
```

```{r} 
# Check the structure of each dataframe

cat("\nBase R (read.csv):\n")
str(admissions_base)

cat("\nTidyverse (read_csv):\n")
str(admissions_tidy)

cat("\nData.table (fread):\n")
str(admissions_dt)
```

We observe that utilizing the `base r` function `read.csv` was the most time-intensive, taking approximately `r runtime_base` seconds to complete. Using `read_csv` from the `tidyverse` was notably faster, with an execution time of approximately `r runtime_tidy` seconds. The fastest function won by a considerable margin, being the `fread` function from the `data.table` package. This function took `r runtime_dt` seconds to execute.. 
In terms of memory usage, `fread` was the least memory-intensive, utilizing `r memuse_dt`. Comparatively, `read.csv` and `read_csv` utilize equal memory (`r memuse_tidy` = `r memuse_base`. 
We also recognize crucial differences in parsed data types for each function. It appears that in all cases, string handling was identical and these columns were handled as `character (chr)` types. The most notable difference was in handling columns with date values. Both `read.csv` and `read_csv` stored these columns as `chr` type, while `fread` converted them to `POSIXct`. This is both memory-efficient and timesaving, as it bypasses any manual date conversion we would have to do when utilizing the other two functions. Ultimately, it appears that `fread` is the most memory-efficient and fastest function for reading plain text data files, while `read_csv` may be more ideal for `tidyverse-based workflows`. The base R function `read.csv` does not appear to be very efficient in speed or memory, nor does it appear to properly parse datetime data types. 

### Q1.2 User-supplied data types

Re-ingest `admissions.csv.gz` by indicating appropriate column data types in `read_csv`. Does the run time change? How much memory does the result tibble use? (Hint: `col_types` argument in `read_csv`.)

**Solution** Re-ingesting with User-Supplied Data Types:
We will now specify column types within the `read_csv` function to see if this affects runtime and/or memory usage.
```{r}
admissions_coltypes <- cols(
  subject_id = col_integer(),
  hadm_id = col_integer(),
  admittime = col_datetime(),
  dischtime = col_datetime(),
  deathtime = col_datetime(),
  admission_type = col_character(),
  admit_provider_id = col_character(),
  admission_location = col_character(),
  discharge_location = col_character(),
  insurance = col_character(),
  language = col_character(),
  marital_status = col_character(),
  race = col_character(),
  edregtime = col_datetime(),
  edouttime = col_datetime(),
  hospital_expire_flag = col_integer()
)
# check runtime 
runtime_tidy_spec <- system.time({
  admissions_tidy_spec <- read_csv('~/mimic/hosp/admissions.csv.gz',
                                   col_types = admissions_coltypes)}
  )[['elapsed']]
# check memory usage
memuse_tidy_spec <- format(object_size(admissions_tidy_spec), units = 'auto')
```
We observe that after specifying the column types ourselves and reading in the data, the process is both faster and more memory-efficient. The runtime is `r runtime_tidy_spec` seconds, compared to `r runtime_tidy` seconds when we didn't specify column types. Similarly, we observe that memory usage is `r memuse_tidy_spec`, compared to `r memuse_tidy` when types were not pre-specified. Ultimately, by avoiding unnecessary character-types, this user specification is able to greatly enhance the speed and storage efficiency of our ingesting process.

## Q2. Ingest big data files
<p align="center">
  <img src="./bigfile.png" width="50%">
</p>
Let us focus on a bigger file, `labevents.csv.gz`, which is about 130x bigger than `admissions.csv.gz`.
```{bash}
ls -l ~/mimic/hosp/labevents.csv.gz
```
Display the first 10 lines of this file.
```{bash}
zcat < ~/mimic/hosp/labevents.csv.gz | head -10
```

### Q2.1 Ingest `labevents.csv.gz` by `read_csv`

<p align="center">
  <img src="./readr_logo.png" width="20%">
</p>
Try to ingest `labevents.csv.gz` using `read_csv`. What happens? If it takes more than 3 minutes on your computer, then abort the program and report your findings. 

**Solution**: Ingesting Large File
```{r}
#| eval: false
system.time({
  labevents_tidy <- read_csv('~/mimic/hosp/labevents.csv.gz')
})
```
I allowed this cell to run for approximately ten minutes (in one particular instance), and the file was eventually read. However, this is a time- and memory-intensive operation to be run locally, so a workaround solution may be warranted. It appears that the large file size and default data parsing may both be contributing to the time-intensive nature of this procedure, so we may consider ingesting only a subset of the data and/or specifying data types beforehand.

### Q2.2 Ingest selected columns of `labevents.csv.gz` by `read_csv`

Try to ingest only columns `subject_id`, `itemid`, `charttime`, and `valuenum` in `labevents.csv.gz` using `read_csv`.  Does this solve the ingestion issue? (Hint: `col_select` argument in `read_csv`.)

**Solution** Ingesting Selected Columns:
``` {r}
#| eval: false
system.time({
  labevents_filtered <- read_csv('~/mimic/hosp/labevents.csv.gz',
                                 col_select = c(
                                   subject_id,
                                   itemid,
                                   charttime,
                                   valuenum
                                 ))
})
```
Selecting a smaller subset of columns did greatly improve our ingestion issue, though it still took quite a bit of time to read in the data (just shy of three minutes, in one particular instance). This is still a marked improvement from the 10+ minutes elapsed while running the prior cell. 

### Q2.3 Ingest a subset of `labevents.csv.gz`

<p align="center">
  <img src="./linux_logo.png" width="20%">
</p>

Our first strategy to handle this big data file is to make a subset of the `labevents` data.  Read the [MIMIC documentation](https://mimic.mit.edu/docs/iv/modules/hosp/labevents/) for the content in data file `labevents.csv`.

In later exercises, we will only be interested in the following lab items: creatinine (50912), potassium (50971), sodium (50983), chloride (50902), bicarbonate (50882), hematocrit (51221), white blood cell count (51301), and glucose (50931) and the following columns: `subject_id`, `itemid`, `charttime`, `valuenum`. Write a Bash command to extract these columns and rows from `labevents.csv.gz` and save the result to a new file `labevents_filtered.csv.gz` in the current working directory. (Hint: Use `zcat <` to pipe the output of `labevents.csv.gz` to `awk` and then to `gzip` to compress the output. Do **not** put `labevents_filtered.csv.gz` in Git! To save render time, you can put `#| eval: false` at the beginning of this code chunk. TA will change it to `#| eval: true` before rendering your qmd file.)

Display the first 10 lines of the new file `labevents_filtered.csv.gz`. How many lines are in this new file, excluding the header? How long does it take `read_csv` to ingest `labevents_filtered.csv.gz`?

**Solution**: Subset Large File
```{bash}
#| eval: false
zcat < ~/mimic/hosp/labevents.csv.gz | 
awk -F, 'BEGIN {OFS=","; print "subject_id,itemid,charttime,valuenum"}
  NR > 1 && ($5 == 50912 || $5 == 50971 || $5 == 50983 || $5 == 50902 || 
             $5 == 50882 || $5 == 51221 || $5 == 51301 || $5 == 50931) {
    print $2, $5, $7, $10
}' | gzip > labevents_filtered.csv.gz
# Count the number of rows, excluding header
zcat labevents_filtered.csv.gz | tail -n +2 | wc -l
```

We observe that there are 32,679,896 lines, excluding our header. Now, we will display the first ten lines of our new file. Since we are including the header in this file, we can add an extra line in the `head` parameter: 
```{bash}
zcat labevents_filtered.csv.gz | head -11
```
Lastly, we can measure how long it takes for `read_csv` to ingest `labevents_filtered.csv.gz`:
```{r}
runtime_filtered <- system.time({
  labevents_filtered <- read_csv('labevents_filtered.csv.gz')
})[['elapsed']]
```
We observe that it takes `r runtime_filtered` seconds to ingest `labevents_filtered.csv.gz` using `read_csv`.
### Q2.4 Ingest `labevents.csv` by Apache Arrow

<p align="center">
  <img src="./arrow_logo.png" width="30%">
</p>

Our second strategy is to use [Apache Arrow](https://arrow.apache.org/) for larger-than-memory data analytics. Unfortunately Arrow does not work with gz files directly. First decompress `labevents.csv.gz` to `labevents.csv` and put it in the current working directory (do not add it in git!). To save render time, put `#| eval: false` at the beginning of this code chunk. TA will change it to `#| eval: true` when rendering your qmd file.

Then use [`arrow::open_dataset`](https://arrow.apache.org/docs/r/reference/open_dataset.html) to ingest `labevents.csv`, select columns, and filter `itemid` as in Q2.3. How long does the ingest+select+filter process take? Display the number of rows and the first 10 rows of the result tibble, and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

Write a few sentences to explain what is Apache Arrow. Imagine you want to explain it to a layman in an elevator. 

**Solution** Ingesting Using Apache Arrow:
First, we will decompress `labevents.csv.gz` to `labevents.csv` and place it in our current working directory.
```{bash}
#| eval: false
gunzip -c ~/mimic/hosp/labevents.csv.gz > labevents.csv
```
Next, we will use `arrow::open_dataset` to ingest `labevents.csv`, select columns, and filter `itemid` in accordance with the guidelines established in the previous exercise.

```{r}
# Time the operation
# Use open_dataset to ingest file
# select columns 
# filter itemid
# arrange by subject_id, charttime, itemid
runtime_arrow <- system.time({
  labevents_filtered <- arrow::open_dataset(
    'labevents.csv', 
    format = 'csv') %>%
    select(subject_id, itemid, charttime, valuenum) %>%
    filter(itemid %in% c(
      50912, 
      50971, 
      50983, 
      50902, 
      50882, 
      51221, 
      51301, 
      50931)) %>%
    collect() %>%
    arrange(subject_id, charttime, itemid)
})[['elapsed']]
print(nrow(labevents_filtered))
print(head(labevents_filtered, 10))
```
Note: Since the operation above has consistently taken < 1 minute to execute locally, I have decided to exclude the `eval = false` specification. 

We observe that the operation took just `r runtime_arrow` seconds, which is much faster than the operations we conducted that were reliant upon local memory. We also display the number of rows, as well as the first ten rows of the filtered dataset. There appear to be 32,679,896 rows. The first ten lines are displayed above.

Comparing this with the first ten rows we displayed in the previous exercise, we have obtained an identical result.

Here is an abridged explanation of Apache Arrow: 
Apache Arrow is a platform utilizing an in-memory, columnar format framework that reduces the memory and CPU toll associated with processing data. It is language-agnostic. It is optimized for handling large-scale data, with its columnar formatting minimizing waste of serialization and deserialization by standardizing the process outright. It also eases the process of data transfer between platforms, as well as moving data from one programming language to another. Technical details aside, it essentially makes data handling much more efficient and versatile.

### Q2.5 Compress `labevents.csv` to Parquet format and ingest/select/filter

<p align="center">
  <img src="./parquet_logo.png" width="30%">
</p>

Re-write the csv file `labevents.csv` in the binary Parquet format (Hint: [`arrow::write_dataset`](https://arrow.apache.org/docs/r/reference/write_dataset.html).) How large is the Parquet file(s)? How long does the ingest+select+filter process of the Parquet file(s) take? Display the number of rows and the first 10 rows of the result tibble and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

Write a few sentences to explain what is the Parquet format. Imagine you want to explain it to a layman in an elevator.
**Solution**: Parquet Formatting
```{r}
# Write the parquet file
  arrow::write_dataset(
  arrow::open_dataset('labevents.csv', format = 'csv'), 
  path = 'part-0.parquet', 
  format = 'parquet'
)
# Measure runtime
# Ingestion, Selection, and Filtering step
runtime_parquet <- system.time({
  labevents_parquet <- arrow::open_dataset('part-0.parquet', 
                      format = 'parquet') %>%
    select(subject_id, itemid, charttime, valuenum) %>%
    filter(itemid %in% c(
      50912, 
      50971, 
      50983, 
      50902, 
      50882, 
      51221, 
      51301, 
      50931)) %>%
    arrange(subject_id, charttime, itemid) %>%
    collect()
})[['elapsed']]
print(nrow(labevents_parquet))
print(head(labevents_parquet, 10))

```
Total runtime for the ingestion, selection, and filtering process was `r runtime_parquet` seconds. Once again, we observe that there are 32,679,896 rows in the dataset. We compare the first ten lines with those in 2.4, verifying an identical result. We note that the first ten rows in 2.3 are not sorted in the same manner, and thus a mismatch is to be expected.

Here is an abridged explanation of the `parquet` file format: The `parquet` format is an open-source, `columnar` file format. In other words, it is column-oriented, as compared to the row-oriented structure of the `csv` file format. This means that every separate column is independently accessible, and data is intuitively organized within columns as opposed to rows. This makes the file format a fantastic candidate for column-wise parallel processing operations. Additionally, this columnar format can minimize file sizes when compared to standard `csv` files. If you are only working with a particular subset of columns, this file format may greatly speed up your workflow and reduce storage and memory tolls. For instance, if you wanted to perform operations on a column within a `csv` file format, you would need to read in the entire file. Conversely, you can access specific columns in isolation using the `parquet` format. Ultimately, this file format allows you to partition particularly sizable datasets into columns and perform operations independently, which maximizes efficiency for column-oriented data tasks and ultimately enables faster processing.

### Q2.6 DuckDB
<p align="center">
  <img src="./duckdb_logo.png" width="20%">
</p>
Ingest the Parquet file, convert it to a DuckDB table by [`arrow::to_duckdb`](https://arrow.apache.org/docs/r/reference/to_duckdb.html), select columns, and filter rows as in Q2.5. How long does the ingest+convert+select+filter process take? Display the number of rows and the first 10 rows of the result tibble and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

Write a few sentences to explain what is DuckDB. Imagine you want to explain it to a layman in an elevator.
**Solution** DuckDB Formatting:
```{r}
runtime_duckdb <- system.time({
  labevents_duckdb <- arrow::to_duckdb(labevents_parquet) %>%
    select(subject_id, itemid, charttime, valuenum) %>%
    filter(itemid %in% c(
      50912, 
      50971, 
      50983, 
      50902, 
      50882, 
      51221, 
      51301, 
      50931)) %>%
    arrange(subject_id, charttime, itemid) %>%
    collect()
})[['elapsed']]
print(nrow(labevents_duckdb))
print(head(labevents_duckdb, 10))
```
We observe that the ingestion, conversion, selection, and filtering step took `r runtime_duckdb` seconds to execute. Once again, we observe that there are 32,679.896 rows in the dataset, and upon inspection, the ten-line preview of our resulting tibble is identical to previous results. Once again, we note that there was no sorting done in Q2.3, making mismatches in the `head` preview an expected result.

Here is an abridged explanation of DuckDB: DuckDB is an analytical database system that can efficiently process large data. It is unique in that it operates locally within your current application or notebook framework, making it simpler and easier to use. It utilizes a columnar file format, similar to `parquet`, and horizontally slices data into `row groups` within each column. This architecture makes it easy to query large datasets locally and with a single server. It integrates well with the tools that data professionals may use on `DataFrames`, like `Pandas` and `Polars`. Notably, it also allows you to run `SQL` queries and operations directly with no overhead requiremenmt. This interoperability makes it an extremely popular tool for data professionals with a variety of tech stacks. Ultimately, the tool bypasses the need for complicated setups and allows users access to powerful data processing tools at smaller scale than traditional distributed processing frameworks.  
## Q3. Ingest and filter `chartevents.csv.gz`

[`chartevents.csv.gz`](https://mimic.mit.edu/docs/iv/modules/icu/chartevents/) contains all the charted data available for a patient. During their ICU stay, the primary repository of a patient’s information is their electronic chart. The `itemid` variable indicates a single measurement type in the database. The `value` variable is the value measured for `itemid`. The first 10 lines of `chartevents.csv.gz` are
```{bash}
zcat < ~/mimic/icu/chartevents.csv.gz | head -10
```
How many rows? 433 million.
```{bash}
#| eval: false
zcat < ~/mimic/icu/chartevents.csv.gz | tail -n +2 | wc -l
```
[`d_items.csv.gz`](https://mimic.mit.edu/docs/iv/modules/icu/d_items/) is the dictionary for the `itemid` in `chartevents.csv.gz`.
```{bash}
zcat < ~/mimic/icu/d_items.csv.gz | head -10
```
In later exercises, we are interested in the vitals for ICU patients: heart rate (220045), mean non-invasive blood pressure (220181), systolic non-invasive blood pressure (220179), body temperature in Fahrenheit (223761), and respiratory rate (220210). Retrieve a subset of `chartevents.csv.gz` only containing these items, using the favorite method you learnt in Q2. 

Document the steps and show code. Display the number of rows and the first 10 rows of the result tibble.
**Solution**: Ingest and Filter ChartEvents

We will utilize `Apache Arrow` to efficiently write this dataset as a `parquet` file. Next, we will select the four key columns we specified in previous exercise. In this step, we will also be filtering for only the relevant vital measurements as specified above. The code below contains comments specifying each step:

```{r}
#| eval: false
# Convert the compressed chartevents file to parquet format
arrow::write_dataset(
  open_dataset('~/mimic/icu/chartevents.csv.gz',
               format = 'csv'),
  path = 'chartevents.parquet',
  format = 'parquet'
)
```

```{r}
# Ingestion, Selection, and Filtering Step
  chartevents_filtered <- arrow::open_dataset('chartevents.parquet',
                      format = 'parquet') %>%
    select(subject_id, itemid, charttime, valuenum) %>%
    filter(itemid %in% c(
      220045,
      220181,
      220179,
      223761,
      220210)) %>%
    arrange(subject_id, charttime, itemid) %>%
    collect()
# Obtain number of rows
print(nrow(chartevents_filtered))
# Display the first ten rows
print(head(chartevents_filtered, 10))
```
We observe that there are 30,195,426 rows in this filtered dataset. The first ten lines are displayed above.
